<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMU Controller</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding: 16px;
            background-color: #f5f5f5;
            -webkit-text-size-adjust: 100%;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 100%;
            margin: 0 auto;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #000;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 8px 0;
            width: 100%;
            font-weight: 500;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .status {
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
        }

        .connected {
            background-color: #dff0d8;
            color: #3c763d;
        }

        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }

        #graph {
            margin-top: 20px;
            width: 100%;
            height: 560px;
        }

        #batteryStatus {
            margin: 10px 0;
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>IMU Controller</h1>
        <div id="status" class="status disconnected">Disconnected</div>
        <button id="connectButton">Connect</button>
        <button id="startButton" disabled>Start Recording</button>
        <button id="stopButton" disabled>Stop Recording</button>
        <button id="exportButton" disabled>Export Graph</button>
        <div id="batteryStatus">Battery: N/A</div>
        <div id="graph"></div>
    </div>
    <script>
        let device = null;
        let commandCharacteristic = null;
        let dataCharacteristic = null;
        let batteryCharacteristic = null;
        let isRecording = false;
        let graphData = [];
        let graphLayout = {
            title: 'Acceleration Data',
            xaxis: { title: 'Time (s)' },
            yaxis: { title: 'Velocity (m/s)' }
        };
        const MAX_DATA_POINTS = 1000;

        async function connectToDevice() {
            console.log("Attempting to connect to device...");
            try {
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'IMU' }],
                    optionalServices: [0xFFE0, 0x180F]
                });
                console.log("Device selected:", device.name);
                const server = await device.gatt.connect();
                console.log("GATT server connected");
                const service = await server.getPrimaryService(0xFFE0);
                console.log("Service found:", service.uuid);
                commandCharacteristic = await service.getCharacteristic(0xFFE2);
                console.log("Command characteristic found");
                dataCharacteristic = await service.getCharacteristic(0xFFE3);
                console.log("Data characteristic found");

                try {
                    const batteryService = await server.getPrimaryService(0x180F);
                    batteryCharacteristic = await batteryService.getCharacteristic(0x2A19);
                    console.log("Battery characteristic found");
                    
                    updateBatteryStatus();
                    
                    await batteryCharacteristic.startNotifications();
                    batteryCharacteristic.addEventListener('characteristicvaluechanged', (event) => {
                        const batteryLevel = event.target.value.getUint8(0);
                        document.getElementById('batteryStatus').textContent = `Battery: ${batteryLevel}%`;
                        console.log("Battery level updated:", batteryLevel, "%");
                    });
                } catch (error) {
                    console.info("Battery monitoring is not supported by this device.");
                    document.getElementById('batteryStatus').textContent = 'Battery: N/A';
                }

                device.addEventListener('gattserverdisconnected', handleDisconnect);

                await receiveDeviceStatus();

                updateStatus('Connected', 'connected');
            } catch (error) {
                if (error.name === 'NotFoundError') {
                    console.warn("Device chooser closed or no device selected:", error);
                } else {
                    console.error("Connection failed:", error);
                }
                updateStatus('Disconnected', 'disconnected');
            }
        }

        async function receiveDeviceStatus() {
            try {
                const value = await commandCharacteristic.readValue();
                if (value.byteLength === 0) {
                    console.warn("Device status is empty. Defaulting to idle state.");
                    document.getElementById('startButton').disabled = false;
                    document.getElementById('stopButton').disabled = true;
                    updateStatus('Idle', 'connected');
                    return;
                }

                const isRecording = value.getUint8(0) === 1;
                if (isRecording) {
                    document.getElementById('startButton').disabled = true;
                    document.getElementById('stopButton').disabled = false;
                    updateStatus('Recording...', 'connected');
                } else {
                    document.getElementById('startButton').disabled = false;
                    document.getElementById('stopButton').disabled = true;
                    updateStatus('Idle', 'connected');
                }
            } catch (error) {
                console.error("Failed to receive device status:", error);
            }
        }

        async function updateBatteryStatus() {
            console.log("Reading battery status...");
            try {
                if (!batteryCharacteristic) {
                    console.warn("Battery characteristic not available.");
                    document.getElementById('batteryStatus').textContent = 'Battery: N/A';
                    return;
                }

                const value = await batteryCharacteristic.readValue();
                const batteryLevel = value.getUint8(0);
                console.log("Battery level:", batteryLevel, "%");
                document.getElementById('batteryStatus').textContent = `Battery: ${batteryLevel}%`;
            } catch (error) {
                console.error("Failed to read battery level:", error);
                document.getElementById('batteryStatus').textContent = 'Battery: Error';
            }
        }

        async function startRecording() {
            console.log("Sending start recording command...");
            try {
                await commandCharacteristic.writeValue(new Uint8Array([0x01]));
                isRecording = true;
                updateStatus('Recording...', 'connected');
                document.getElementById('startButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                console.log("Recording started");
            } catch (error) {
                console.error("Failed to start recording:", error);
            }
        }

        async function stopRecording() {
            console.log("Sending stop recording command...");
            try {
                await commandCharacteristic.writeValue(new Uint8Array([0x02]));
                isRecording = false;
                updateStatus('Downloading data...', 'connected');
                console.log("Recording stopped, starting data download...");
                await downloadData();
                document.getElementById('startButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
            } catch (error) {
                console.error("Failed to stop recording:", error);
            }
        }

        async function downloadData() {
            console.log("Starting data download...");
            graphData = [];
            
            try {
                console.log("Requesting buffer size...");
                let bufferSize = 0;
                for (let attempt = 0; attempt < 3; attempt++) {
                    const bufferSizeValue = await commandCharacteristic.readValue();
                    if (bufferSizeValue.byteLength >= 2) {
                        bufferSize = bufferSizeValue.getUint16(0, true);
                        break;
                    }
                    console.warn(`Invalid buffer size received, retrying (${attempt + 1}/3)...`);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (bufferSize === 0) {
                    console.warn("Failed to receive buffer size. Defaulting to MAX_DATA_POINTS.");
                    bufferSize = MAX_DATA_POINTS;
                }

                console.log(`Buffer size: ${bufferSize} data points`);
                updateStatus('Downloading data...', 'connected');

                console.log("Requesting data in chunks...");
                await commandCharacteristic.writeValue(new Uint8Array([0x03]));

                let totalChunks = 0;
                while (true) {
                    const value = await dataCharacteristic.readValue();
                    if (value.byteLength === 0) {
                        console.log("End of data received");
                        break;
                    }

                    if (value.byteLength < 8) {
                        throw new Error("Invalid data chunk received from the device.");
                    }

                    const timestamp = value.getUint32(0, true);
                    const velocity = value.getFloat32(4, true);

                    graphData.push({ x: timestamp / 1000, y: velocity });
                    console.log(`Received data point: timestamp=${timestamp}, velocity=${velocity}`);

                    totalChunks++;
                }

                plotGraph();
                document.getElementById('exportButton').disabled = false;
                updateStatus('Data downloaded', 'connected');
                console.log("Data download complete");
            } catch (error) {
                console.error("Failed to download data:", error);
                updateStatus('Download failed', 'disconnected');
            }
        }

        function plotGraph() {
            const trace = {
                x: graphData.map(point => point.x),
                y: graphData.map(point => point.y),
                mode: 'lines',
                type: 'scatter'
            };
            Plotly.newPlot('graph', [trace], graphLayout);
        }

        function exportGraph() {
            Plotly.toImage(document.getElementById('graph'), { format: 'png' }).then(url => {
                const link = document.createElement('a');
                link.href = url;
                link.download = 'graph.png';
                link.click();
            });
        }

        function handleDisconnect() {
            updateStatus('Disconnected', 'disconnected');
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = true;
        }

        function updateStatus(message, className) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${className}`;
        }

        document.getElementById('connectButton').addEventListener('click', connectToDevice);
        document.getElementById('startButton').addEventListener('click', startRecording);
        document.getElementById('stopButton').addEventListener('click', stopRecording);
        document.getElementById('exportButton').addEventListener('click', exportGraph);
    </script>
</body>
</html>